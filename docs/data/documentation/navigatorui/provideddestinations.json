{"schemaVersion":{"patch":0,"major":0,"minor":3},"identifier":{"url":"doc:\/\/NavigatorUI\/documentation\/NavigatorUI\/ProvidedDestinations","interfaceLanguage":"swift"},"primaryContentSections":[{"kind":"content","content":[{"level":2,"anchor":"Overview","type":"heading","text":"Overview"},{"inlineContent":[{"type":"text","text":"NavigationDestination’s are a powerful concept, but they require the destination to provide the views needed as part of the protocol."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"And in many cases that’s not a problem."}],"type":"paragraph"},{"syntax":"swift","code":["nonisolated public enum SharedDestinations: NavigationDestination {","    case newOrder","    case orderDetails(Order)","    case produceDetails(Product)","","    public var body: some View {","        switch self {","        case .newOrder:","            NewOrderView()","        case .orderDetails(let order):","            OrderDetailsView(order)","        case .produceDetails(let product):","            ProduceDetailsView(for: product)","        }","    }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"But what happens when that information isn’t available? Or can’t be seen? This is a chicken and egg situation that’s extremely common in modern modular applications."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"To illustrate, what if our "},{"type":"codeVoice","code":"SharedDestinations"},{"type":"text","text":" enumeration wants to live in a "},{"type":"codeVoice","code":"Shared"},{"type":"text","text":" module in our application, imported so that any module in our application can see it and use it?"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Fine. Just define it there."}],"type":"paragraph"},{"syntax":"swift","code":["nonisolated public enum SharedDestinations: NavigationDestination {","    case newOrder","    case orderDetails(Order)","    case produceDetails(Product)","","    public var body: some View {","        ???","    }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Except… the problem is that "},{"type":"codeVoice","code":"NavigationDestination"},{"type":"text","text":" is expected to provide a View body that returns the destination views for each of those cases… but the Shared module can’t "},{"inlineContent":[{"type":"text","text":"see"}],"type":"emphasis"},{"text":" those views. It knows nothing about them.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Order"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Product"},{"text":" modules import ","type":"text"},{"type":"codeVoice","code":"Shared"},{"text":", not the other way around. Nor do we want to create a module that does so.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"NavigationProvidedDestination provides the solution.","type":"text"}]},{"type":"heading","level":3,"anchor":"NavigationProvidedDestination","text":"NavigationProvidedDestination"},{"inlineContent":[{"text":"Just change the destination type to be ","type":"text"},{"type":"codeVoice","code":"NavigationProvidedDestination"},{"text":".","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["nonisolated public enum SharedDestinations: NavigationProvidedDestination {","    case newOrder","    case orderDetails(Order)","    case produceDetails(Product)","}"]},{"inlineContent":[{"text":"And you’re good to go. ’NavigationProvidedDestination provides a custom view body that promises to provide the views in question.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"But… how?","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"It asks Navigator for them, of course.","type":"text"}],"type":"paragraph"},{"type":"heading","level":3,"anchor":"Registering-Provided-Destinations","text":"Registering Provided Destinations"},{"inlineContent":[{"text":"But that just kicks the can down the road. ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"Where does Navigator get them from?","type":"text"}]}],"type":"paragraph"},{"inlineContent":[{"text":"The application, of course. It registers them using a new modifier: ","type":"text"},{"type":"codeVoice","code":"onNavigationProvidedView"},{"text":".","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["import Shared","import Orders","import Products","import NavigatorUI","import SwiftUI","","struct ContentView: View {","    let navigator: Navigator = .init(configuration: .init())","    var body: some View {","        RootTabView()","            \/\/ provide Shared views","            .onNavigationProvidedView(SharedDestinations.self) {","                switch $0 {","                case .newOrder:","                    NewOrderView()","                case .orderDetails(let order:","                    OrderDetailsView(order)","                case .produceDetails(let product):","                    ProductDestinations.details(product)","                }","            }","            \/\/ setup managed navigation root","            .navigationRoot(navigator)","    }","}"]},{"inlineContent":[{"text":"In effect, it’s just another version of ","type":"text"},{"type":"codeVoice","code":"navigationDestination(for:)"},{"text":", a concept borrowed and updated for our purposes.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"After all, it’s the app that sees all and knows all. And in this case, it’s also trusted to provide all.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The application knows about the ","type":"text"},{"type":"codeVoice","code":"Orders"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"Products"},{"text":" modules, and it and only it can see into them to get the public views needed.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"And in the case of the ","type":"text"},{"type":"codeVoice","code":"Products"},{"text":" module, it can’t even see the views. It just asks ","type":"text"},{"type":"codeVoice","code":"ProductDestinations"},{"text":" to provide what’s needed. (ProductDestinations is a ","type":"text"},{"type":"codeVoice","code":"NavigationDestination"},{"text":" type.)","type":"text"}],"type":"paragraph"},{"type":"aside","style":"note","name":"Note","content":[{"type":"paragraph","inlineContent":[{"text":"This concept works hand in hand with the concept of NavigationDestination auto-registration developed for Navigator 1.2. One can get and present a new orders view or product view without caring what views that view may push or present.","type":"text"}]}]},{"type":"heading","level":3,"anchor":"Exposed-Destinations","text":"Exposed Destinations"},{"inlineContent":[{"text":"This system works well for shared dependencies, but it can also be useful to let a module expose a custom set of external view dependencies.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["nonisolated public enum OrdersExternalViews: NavigationProvidedDestination {","    case homeAddressEntryScreen","}"]},{"inlineContent":[{"text":"Here the ","type":"text"},{"type":"codeVoice","code":"Orders"},{"text":" module is basically saying, “Hey, I may want to show the screen that lets the user enter his home address. Somebody needs to give it me.”","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"With that someone being the application, of course.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":[".onNavigationProvidedView(OrdersExternalViews.self) { _ in","    ProfileDestinations.addressEntry \/\/ only one view, so no switch needed","}"]},{"inlineContent":[{"text":"This makes it much, much easier to create modular applications that minimizes the known dependencies between modules. Use shared dependencies for common cases, and custom external dependencies when and where needed.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The alternative is for module A to import module B and vice-versa… and that tends to eliminate most the benefits we gained from modularization in the first place.","type":"text"}],"type":"paragraph"},{"type":"heading","level":3,"anchor":"NavigationProvidedView","text":"NavigationProvidedView"},{"inlineContent":[{"text":"If one were to look at the view body provided for ","type":"text"},{"type":"codeVoice","code":"NavigationProvidedDestination"},{"text":" you’d see the following:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["extension NavigationProvidedDestination {","    public var body: some View {","        NavigationProvidedView(for: self)","    }","}"]},{"inlineContent":[{"type":"codeVoice","code":"NavigationProvidedDestination"},{"text":" just punts and calls ","type":"text"},{"type":"codeVoice","code":"NavigationProvidedView"},{"text":". Digging further, we’d see that the relevant portion of ","type":"text"},{"type":"codeVoice","code":"NavigationProvidedDestination"},{"text":" looks like this.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["public struct NavigationProvidedView<D: NavigationDestination, P: View>: View {","    @Environment(\\.navigator) private var navigator","    ...","    public var body: some View {","        if let view = navigator.navigationProvidedView(for: destination) {","            AnyView(view)","        } else if let placeholder {","            placeholder","        } else {","            #if DEBUG","            Text(\"Missing Provider for \\(type(of: self)).\\(self)\")","            #else","            EmptyView()","            #endif","        }","    }","}"]},{"inlineContent":[{"text":"Simply put, and as mentioned earlier, ","type":"text"},{"type":"codeVoice","code":"NavigationProvidedView"},{"text":" is just a view that knows how to ask Navigator to find the correct view for that type.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"If no navigation provided destination is found then the view returns a placeholder view. And if no placeholder is found, it returns ","type":"text"},{"type":"codeVoice","code":"EmptyView"},{"text":" in production mode, but something a bit more informative when running in ","type":"text"},{"type":"codeVoice","code":"DEBUG"},{"text":" mode.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"But… what’s a placeholder?","type":"text"}],"type":"paragraph"},{"text":"Placeholder Views","level":3,"type":"heading","anchor":"Placeholder-Views"},{"type":"paragraph","inlineContent":[{"type":"text","text":"As one might expect, it’s just a way to provider our own custom placeholder views for our own types if we so desire. Consider this potential implementation of "},{"type":"codeVoice","code":"SharedDestinations"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["nonisolated public enum SharedDestinations: NavigationDestination {","    case newOrder","    case orderDetails(Order)","    case produceDetails(Product)","","    public var body: some View {","        NavigationProvidedView(for: self) {","            switch self {","            case .newOrder:","                MockNewOrderView()","            case .orderDetails(let order):","                MockOrderDetailsView(order)","            case .produceDetails(let product):","                MockProduceDetailsView(for: product)","            }","        }","    }","}"]},{"inlineContent":[{"text":"One could also follow the behavior of ","type":"text"},{"type":"codeVoice","code":"NavigationProvidedView"},{"text":", returning mocks in DEBUG mode and launch an “Oops!” page so your users could tell you that something is awry should this code somehow make it into production.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"It’s up to you."}],"type":"paragraph"},{"type":"aside","style":"note","name":"Note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Not knowing if a view is registered may seem scary, but in reality we’re just mimicking the behavior of "},{"type":"codeVoice","code":"NavigationLink(value:label:)"},{"type":"text","text":" or "},{"type":"codeVoice","code":"NavigationPath"},{"type":"text","text":" when a unknown type is pushed and we see an empty view. Sometimes you just have to trust the app."}]}]},{"level":3,"text":"Single Views","type":"heading","anchor":"Single-Views"},{"inlineContent":[{"text":"Thus far we seen ","type":"text"},{"type":"codeVoice","code":"NavigationProvidedView"},{"text":" used to manage replacements for entire types. But one can also use it to provide single views when needed. Consider:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["nonisolated public enum HomeDestinations: NavigationDestination {","    ...","    case pageN(Int)","    case external","","    var body: some View {","        switch select {","        ...","        case .pageN(let n):","            HomePageNView(number: n)","        case .external:","            NavigationProvidedView(for: HomeDestinations.external)","        }","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"Here we provide known views for most of our cases. But for ","type":"text"},{"code":"external","type":"codeVoice"},{"text":" we ask the application to provide it for us.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":[".onNavigationProvidedView(HomeDestinations.self) { destination in","    switch destination {","    case .external:","        SomeExternalView()","    default:","        EmptyView()","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that in the default we’re seemingly return EmptyView for all of the other cases, but that’s just to make the compiler happy. All of the other cases would have been caught and handled earlier in the original "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" statement."}]},{"inlineContent":[{"text":"All in all, use this particular technique judiciously. As we saw earlier it’s usually better for a module to expose a custom enumeration explicitly exposed and defined to manage external view dependencies.","type":"text"}],"type":"paragraph"},{"level":3,"text":"Dependency Injection and NavigationViewProviding","type":"heading","anchor":"Dependency-Injection-and-NavigationViewProviding"},{"inlineContent":[{"text":"One final technique that’s completely different but worth mentioning uses the ","type":"text"},{"code":"NavigationViewProviding","type":"codeVoice"},{"text":" protocol. Effectively, you’re going to force your application’s dependency injection system to give you what you need.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Let’s look at a portion of our dependency requirements for our “Home” module."}],"type":"paragraph"},{"code":["public protocol HomeDependencies {","    ...","    @MainActor var homeExternalViewProvider: any NavigationViewProviding<HomeExternalViews> { get }","    ...","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"This tells the application that it ","type":"text"},{"inlineContent":[{"text":"must","type":"text"}],"type":"emphasis"},{"type":"text","text":" return something that conforms to "},{"type":"codeVoice","code":"NavigationViewProviding"},{"type":"text","text":", which is simply a protocol that promises to return a view for a given type when asked."}],"type":"paragraph"},{"type":"codeListing","code":["public protocol NavigationViewProviding<D> {","    associatedtype D: NavigationViews","    func view(for destination: D) -> AnyView","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this case, our "},{"type":"codeVoice","code":"HomeExternalViews"},{"type":"text","text":" enumeration conforms to "},{"type":"codeVoice","code":"NavigationViews"},{"type":"text","text":" (basically just "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":")."}]},{"syntax":"swift","type":"codeListing","code":["nonisolated public enum HomeExternalViews: NavigationViews {","    case external","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"So when the application constructs our module’s dependencies, it’s forced to give us what we need."}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Home needs an external view from somewhere. Provide it.","public class AppResolver: AppDependencies, HomeDependencies, ...  {","    ...","    @MainActor public var homeExternalViewProvider: any NavigationViewProviding<HomeExternalViews> {","        NavigationViewProvider {","            switch $0 {","            case .external:","                SettingsDestinations.external","            }","        }","    }","}"]},{"inlineContent":[{"text":"All of which lets us finally access the view needed in ","type":"text"},{"code":"HomeDestinations","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["internal struct HomeDestinationsView: View {","    \/\/ Selected destination to display","    let select: HomeDestinations","    \/\/ Obtain home dependency resolver","    @Environment(\\.homeDependencies) var resolver","    \/\/ Standard view body","    var body: some View {","        switch select {","        ...","        case .external:","            resolver.homeExternalViewProvider.view(for: .external)","        ...","    }","}"]},{"inlineContent":[{"text":"The module described its dependencies, the application provided them, and the view accessed them. And in this case we ","type":"text"},{"inlineContent":[{"text":"know","type":"text"}],"type":"emphasis"},{"text":" we have what we need.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"That said, it’s a lot easier to use ","type":"text"},{"code":"NavigationProvidedDestination","type":"codeVoice"},{"text":" and eliminate all of the extra boilerplate and moving parts.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"One enumeration on one side, one registration on the other side, and you’re done.","type":"text"}],"type":"paragraph"}]}],"metadata":{"modules":[{"name":"NavigatorUI"}],"role":"article","title":"Navigation Provided Destinations","roleHeading":"Article"},"kind":"article","hierarchy":{"paths":[["doc:\/\/NavigatorUI\/documentation\/NavigatorUI"]]},"seeAlsoSections":[{"title":"Advanced Topics","anchor":"Advanced-Topics","generated":true,"identifiers":["doc:\/\/NavigatorUI\/documentation\/NavigatorUI\/AdvancedDestinations"]}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/navigatorui\/provideddestinations"]}],"abstract":[{"type":"text","text":"Creating and using NavigationDestination’s when you don’t know the destination."}],"sections":[],"references":{"doc://NavigatorUI/documentation/NavigatorUI":{"abstract":[{"text":"Managed NavigationStacks for SwiftUI.","type":"text"}],"type":"topic","kind":"symbol","url":"\/documentation\/navigatorui","identifier":"doc:\/\/NavigatorUI\/documentation\/NavigatorUI","title":"NavigatorUI","role":"collection"},"doc://NavigatorUI/documentation/NavigatorUI/AdvancedDestinations":{"title":"Advanced Destinations","identifier":"doc:\/\/NavigatorUI\/documentation\/NavigatorUI\/AdvancedDestinations","type":"topic","abstract":[{"type":"text","text":"Building NavigationDestinations that access the environment and other use cases"}],"role":"article","kind":"article","url":"\/documentation\/navigatorui\/advanceddestinations"}}}